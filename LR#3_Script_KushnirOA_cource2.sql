--Лабораторная 3. 
--Работайте с вашей БД TulaTech_<ВашаФамилия>. 
--
-- Задание 1. Модификация данных в БД
--1.	Добавьте в таблицу jobs  запись с учетом заданных в таблице ограничений целостности. Используйте конструктор VALUES. Приведите код.
--

insert into schema1.jobs
values ('111AAA', 'CEO', 11000, 25000);

select * from schema1.jobs;


--2.	Напишите ОДИН оператор Insert, для добавления в таблицу jobs 2 записей. Приведите код:
--a.	одна запись должна соответствовать ограничениям целостности 
--b.	одна запись должна нарушать одно или несколько ограничений целостности. 
--c.	Каков результат?

insert into schema1.jobs(job_id, job_title, max_salary)
values ('222BBB', 'CMO', 25000), -- валидная запись
		('333CCC', default, 26000); -- нарушено ограничение check - max_salary больше установленной

select * from schema1.jobs;
-- в результате ни одна из записей не добавлена в таблицу

--
--3.	Добавьте в таблицу countries (справочник стран) 3 страны. Приведите код
--
-- для удобства заполнения и проверки, что страны в справочнике не повторяются, 
-- добавлю ограничение unique на столбец country_name:

alter table schema1.countries
add constraint ak_country unique (country_name);

-- добавляю страны
insert into schema1.countries(country_name)
values  ('Россия'), ('Белоруссия'), ('Армения');

-- для дефолтных значений в таблице departments (см. предыдущую ЛР 2):
-- нужен адрес с нулевыми значениями id адреса и страны
--insert into schema1.countries
--overriding system value
--values (0, 'ND');

select * from schema1.countries;

--4.	Добавьте в таблицу addresses по 2 адреса для каждой страны.
--a.	Для ввода данных в столбец country_id используйте подзапрос к таблице countries. 
--      Подзапрос должен возвращать country_id по названию страны

insert into schema1.addresses
values (7, 'наб Краснопресненская, дом 3 стр. 44', '103275', 'Москва', 
		(select country_id from schema1.countries where country_name = 'Россия'));

insert into schema1.addresses
values (2, 'пр Ленина, дом 92 стр. 3', '300012', 'Тула', 
		(select country_id from schema1.countries where country_name = 'Россия'));
	
insert into schema1.addresses
values (8, 'ул Димитрова, дом 2 стр. 2', '220005', 'Минск', 
		(select country_id from schema1.countries where country_name = 'Белоруссия'));
	
insert into schema1.addresses
values (4, 'ул Зеленогурская, 10', '210007', 'Витебск', 
		(select country_id from schema1.countries where country_name = 'Белоруссия'));

insert into schema1.addresses
values (9, 'пр Саят-Новы, 67', '0824', 'Ереван', 
		(select country_id from schema1.countries where country_name = 'Армения'));
	
insert into schema1.addresses
values (6, 'пр Тиграна Меца, дом 1/3', '3123', 'Гюмри', 
		(select country_id from schema1.countries where country_name = 'Армения'));

select * from schema1.addresses;

--
--5.	Добавьте в таблицу employees сведения о 3 сотрудниках. Приведите код:
--a.	У каждого сотрудника должно быть определено не менее 2 номеров телефонов. 
--b.	Успешна ли ваша попытка?
select * from schema1.employees;

select * from schema1.departments;

select * from schema1.jobs;

insert into schema1.employees
values ('000001', 'Jack', 'Smith', 'js@mail.ru', '8(910)555-6677, 23-34-45', CURRENT_DATE, '56RTY6', 8030, 999),
('000002', null, 'Tramp', 'tr@mail.ru', '8(910)666-6677, 77-11-22', CURRENT_DATE, '1001W', 18050, 333),
('000003', 'Nora', 'Galkina', 'ng@mail.ru', '8(920)455-9600, 42-25-75', CURRENT_DATE, '111AAA', 20030, 999);

-- Возникает ошибка - значение слишком длинное для типа character varying(20). 
-- То есть два телефонных номера не умещаются в емкость ячейки, определенной для телефонного номера

--c.	Что необходимо для заполнения таблицы employees данными?
-- Необходимо либо увеличить емкость типа данных, например, character varying(60), либо 
-- вообще не указывать длину varchar
-- Но лучше изменить тип данных на массив строк. 

-- Так как в таблице уже были данные, перед преобразованием в массив 
-- добавлю фигурные скобки вокруг номеров телефонов в колонке phone_number: 

update schema1.employees 
set phone_number = '{'||phone_number||'}';

-- Теперь можно преобразовать строку в массив строк:

alter table schema1.employees
alter column phone_number type character varying(20)[] 
using phone_number::character varying(20)[];

-- И снова попытаться добавить данные с учетом изменения типа колонки с телефонами:

insert into schema1.employees
values ('000001', 'Jack', 'Smith', 'js@mail.ru', '{"8(910)555-6677", "23-34-45"}', CURRENT_DATE, '56RTY6', 8030, 999),
('000002', null, 'Tramp', 'tr@mail.ru', '{"8(910)666-6677", "77-11-22"}', CURRENT_DATE, '1001W', 18050, 333),
('000003', 'Nora', 'Galkina', 'ng@mail.ru', '{"8(920)455-9600", "42-25-75"}', CURRENT_DATE, '111AAA', 20030, 999);

-- данные успешно добавлены

--6.	Удалите из таблицы countries 1 запись. Приведите код. Объясните полученный результат.
--
delete from schema1.countries
where country_id = (select min(country_id) from schema1.countries )
;

-- Первая запись в таблице countries уже используется в таблице addresses в качестве внешнего ключа
-- Поэтому ее удаление при текущих настройках ограничения внешнего ключа on delete no action невозможно

--7.	Добавьте первому сотруднику дополнительный номер телефона. 

--Комментарий СИ:
-- Здесь лучше использовать функцию добавления элемента в массив, так как в данном случае мы не обязаны знать, 
-- что добавляем именно 3 номер телефона
--update schema1.employees
--set phone_number[3] = '+1(110)405-8600' --сделать через array_append
--where employee_id = 1;

update schema1.employees
set phone_number = array_append(phone_number, '+1(110)405-8601') 
where employee_id = 1;

--8.	Измените у второго сотрудника номер 2 телефона (используйте указатель на соответствующий элемент массива)
--
update schema1.employees
set phone_number[2] = '+1(111)111-1111'
where employee_id = 2;

--9.	У третьего сотрудника удалите 2-ой телефон из списка телефонов.
--
update schema1.employees
set phone_number = array_remove(phone_number, phone_number[2]) 
where employee_id = 3;

--Задание 2. Управление транзакциями
--1.	Используя явную транзакцию выполните следующую задачу:
--a.	Добавьте запись о новой должности в таблицу jobs

begin;
insert into schema1.jobs
values ('2CPO', 'CPO-M', 19000, 23000);

select * from schema1.jobs; -- проверяю, что запись добавилась

--b.	Добавьте сотрудника, который эту должность будет занимать.

insert into schema1.employees
values ('000001', 'Jack', 'Smith', 'js@mail.ru', '{"8(910)555-6677", "23-34-45"}', CURRENT_DATE, '1CPO',22000, 999)
;

--2.	Протестируйте созданную транзакцию. Убедитесь, что в случае если возникает ошибка при добавлении должности или сотрудника, никакие данные в БД не сохраняются
--
-- я создала ошибку нарушения уникальности первичного ключа employee_id во время добавления сотрудника,
-- фиксирую явную транзакцию и проверяю таблицы: 

commit;

select * from schema1.jobs;
select * from schema1.employees;

-- Я убедилась, что ни в одну из таблиц не добавились строки: даже в таблицу jobs,
-- в которую внутри явной транзакции строка добавилась без ошибок.
-- Следовательно, явная транзакция считается сервером одной единой транзакцией,
-- и если хотя бы одна из операций внутри нее вызвала ошибку, 
-- отменяется вся явная транзакция целиком

--3.	Используя явную транзакцию выполните следующую задачу:
--a.	Добавьте сотрудника, который должен занимать новую должность.

begin;

insert into schema1.employees
values ('000004', 'Ivan', 'Ivanov', 'ii@mail.ru', '{"4(911)555-6677", "29-30-45"}', CURRENT_DATE, '2CPO',22000, 999)
;

alter table schema1.employees
drop constraint phone_number_chk;

insert into schema1.employees
values ('000004', 'Ivan', 'Ivanov', 'ii@mail.ru', '{"4(911)555-6677", "29-30-45"}', CURRENT_DATE, '2CPO',22000, 999)
;
-- теперь запись не вставляется, т.к. она нарушает ограничение внешнего ключа:
-- информации о новой должности нет в таблице jobs

--b.	Добавьте запись о новой должности

insert into schema1.jobs
values ('2CPO', 'CPO-M', 19000, 23000);

-- Возникла ошибка:
-- ERROR: current transaction is aborted, commands ignored until end of transaction block

commit;

--4.	Каков результат?

-- Таким образом, подтверждается поведение сервера, когда при наличии ошибки хотя бы в одной
-- операции транзакции отменяются изменения всей транзакции целиком.
-- Более того, как только встретилась ошибка, сервер отказывается продолжать выполнение 
-- каких-то новых операций в блоке явной транзакции и ожидает команды ее завершения. 


--Управление конкурентным доступом (READ COMMITTED)
--1-я сессия:
--1.	Выполните проверку уровня изоляции, используемого в текущей сессии.
show transaction isolation level; 
-- READ COMMITTED

--2.	Откройте явную транзакцию с уровнем изоляции по умолчанию.
begin;
-- её id:
select txid_current(); 

--3.	Выполните изменение эл.почты первого сотрудника. 
update schema1.employees
set email = '1new1@gmail.ru'
where employee_id = 1;

select * from schema1.employees;

--4.	Транзакцию не закрывайте!!!
--
--2-я сессия:
--5.	Откройте второе соединение к вашей БД. 
--6.	Откройте явную транзакцию с уровнем изоляции по умолчанию. 
--7.	Выполните запрос к таблице employees. Убедитесь, что изменения, сделанные в параллельной транзакции не видны

-- да, не видны. При данном уровне изоляции READ COMMITTED второе соединение увидит изменения, только когда они буду зафиксированы

--8.	Измените эл.почту первого сотрудника: к текущему содержимому столбца добавьте еще один адрес через запятую (значение должно отличаться от введенного в первой транзакции) 
--9.	Зафиксируйте транзакцию. 
--10.	Каков результат?

-- 2-ая транзакция "зависла", т.к. первая еще не зафиксировала изменения в той же строке,
-- а значит, возник конфликт "писателей", сервер блокировал второго "писателя" 

--
--1-я сессия:
--11.	Зафиксируйте транзакцию 
commit;
-- результат commit - обновлено 0 строк, т.е. на самом деле откат изменений,
-- ведь 2-я транзакция успела дать команду commit раньше

--12.	Проверьте адрес эл.почты у первого сотрудника. Объясните результат.
select email from schema1.employees
where  employee_id = 1;

-- Сервер не показывает изменений строки в данной сессии, 
-- видимо, потому, что транзакция во 2-ой сессии так и осталась пока "висеть" заблокированной, 
-- и ее результат пока не виден в 1-й сессии
-- 
select xmin, xmax, * from schema1.employees;
-- xmax изменяемой колонки так и остался равен номеру 1 транзакции, хотя она была закрыта

-- вижу блокировки наших явных транзакций:
select * from pg_locks;

-- Но если открыть совсем новую 3-ю сессию, и начать третью транзакцию,
-- у которой такой же уровень изоляции, как и у первых двух,
-- запрос к таблице schema1.employees уже показывает изменения,
-- внесенные второй транзакцией

--Работайте в текущей сессии!
--13.	Откройте новую явную транзакцию с уровнем изоляции по умолчанию.
begin;
select txid_current(); 
-- после открытия в 1-й сессии новой явной транзакции была разблокирована транзакция во 2-й сессии,
-- сервер "сказал", что ее именения были зафиксированы.
-- Как я понимаю, это произошло потому, что уровень изоляции READ COMMITTED новой транзакции в 1 сессии 
-- обязывает сервер показать все уже зафиксированные изменения в базе, 
-- поэтому серверу уже не нужно блокировать 2-ю сессию

--14.	Напишите запрос к таблице сотрудники
select xmin, xmax, * from schema1.employees;

-- результат показывает, что последние именения в строке первого сотрудника были действительно сделаны 2-й сессией	

--2-я сессия:
--15.	Откройте явную транзакцию с уровнем изоляции по умолчанию. 
--16.	Измените второй телефон третьего сотрудника 
--17.	Зафиксируйте транзакцию.

-- изменения 2-й сессии успешно зафиксированы, т.к. 1-я сессия читала данные, но не пыталась изменить их
-- и при данном уровне изоляции транзакций не возникает блокировок
--
--1-я сессия:
--18.	Напишите запрос к таблице сотрудники.
select xmin, xmax, * from schema1.employees;
--19.	Как изменился результат выборки и почему?

-- Изменения, внесенные 2-й сессией, отображаются теперь и в открытой транзакции 1-й сессии,
-- т.к. уровень изоляции транзакции 1-й сессии READ COMMITED, что предполагает 
-- отображение зафиксированных в базе изменений на момент начала вполнения каждого нового оператора внутри транзакции.
-- А 2-я сессия сделала и зафиксировала изменения к моменту начала выполнения последнего запроса на чтентие в 1-й сессии, 
-- поэтому в 1-й сессии изменения видны даже внутри одной явной транзакции - т.н. неповторяемое чтение.

--20.	Закройте транзакцию
--
commit;


